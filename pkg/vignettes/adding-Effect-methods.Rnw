%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Defining Effect Methods for Other Models}
%% vignette index specifications need to be *after* \documentclass{}
%%\VignetteEngine{knitr::knitr}
%%\VignetteIndexEntry{Computing Effects for Other Statistical Models}
%%\VignettePackage{effects}

\documentclass{article}


\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[american]{babel}
\newcommand{\R}{{\sf R}}
\usepackage{url}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{fancyvrb}
\usepackage{natbib}
\usepackage{amsmath}
\VerbatimFootnotes
\bibliographystyle{chicago}
%\usepackage{amsmath,amsfonts,amssymb}
%\usepackage{natbib}
%\bibliographystyle{abbrvnat}
%\usepackage[margin=1in]{geometry}

\newcommand{\x}{\mathbf{x}}
\newcommand{\code}[1]{\normalfont\texttt{\hyphenchar\font45\relax #1}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\tild}{\symbol{126}}
\newcommand{\Rtilde}{\,\raisebox{-.5ex}{\code{\tild{}}}\,}
\newcommand{\captilde}{\mbox{\protect\Rtilde}} % use in figure captions.
\newcommand{\Rmod}[2]{\code{#1 \raisebox{-.5ex}{\tild{}} #2}}
\newcommand{\Rmoda}[2]{\code{#1} &\code{\raisebox{-.5ex}{\tild{}} #2}}
\newcommand{\Rmodb}[2]{\code{#1 &\raisebox{-.5ex}{\tild{}}& #2}}
\newcommand{\C}{\mathbf{C}}
\newcommand{\betahat}{\widehat{\beta}}
\newcommand{\bbetahat}{\widehat{\boldsymbol{\beta}}}
\newcommand{\bbeta}{\boldsymbol{\beta}}
\newcommand{\xbf}{\x_{\backslash{}f}}
\newcommand{\hbf}{h_{\backslash{}f}}
\newcommand{\xtb}{\x_{2\backslash{}f}}
\newcommand{\xbfi}{\x_{\backslash{}f,i}}
\newcommand{\inter}[2]{\mbox{$#1$:$#2$}}
\newcommand{\cross}[2]{\mbox{$#1$\code{*}$#2$}}
\newcommand{\N}{\mathrm{N}}
\newcommand{\fn}{\textbf}
\newcommand{\pkg}[1]{\code{#1}}
\newcommand{\proglang}[1]{\code{#1}}
\newcommand{\yx}{\widehat{y}(\x)}
\newcommand{\lvn}[1]{\mbox{$\log(\mbox{\texttt{#1}})$}}

\begin{document}

\title{Defining Effect Methods for Other Models}

\author{John Fox and Sanford Weisberg}

\date{Revised, \today}

\maketitle

<<setopts,echo=FALSE>>=
library("knitr")
opts_chunk$set(fig.width=5,fig.height=5,tidy=TRUE,
               out.width="0.8\\textwidth",echo=TRUE)
options(prompt=" ")
@ 


<<echo=FALSE, results='hide', include=FALSE>>=
#options(continue="+    ", prompt="R> ", width=76)
options(show.signif.stars=FALSE)
options(scipen=3)
@

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
tidy=FALSE,fig.width=5,fig.height=5,cache=FALSE,comment=NA, prompt=TRUE
)
render_sweave()
@


<<echo=FALSE, results='hide', include=FALSE>>=
options(continue="    ", prompt=" ", width=76)
options(show.signif.stars=FALSE)
options(scipen=3)

@

The \code{effects} package in \R{} draws graphs that visualize a fitted response surface of a fitted model in problems with a linear predictor.  Many modeling paradigms that can be fit with base \R{} or contributed packages fit into this framework, including methods for linear, multivariate linear, and generalized linear models fit by the standard \code{lm} and \code{glm} functions and by the \code{svyglm} function in the \code{survey} package \citep{Lumley04}; linear models fit by generalized least squares using the \code{gls} function in the \pkg{nlme} package \citep{Pinheiro16}; multinomial regression models fit by \code{multinom} in the \pkg{nnet} package \citep{VenablesRipley02};  ordinal regression models using \code{polr} from the \pkg{MASS} package \citep{VenablesRipley02} and \code{clm} and \code{clm2} from the \pkg{ordinal} package \citep{Christensen15}; linear and generalized linear mixed models using the \code{lme} function in the \pkg{nlme} package \citep{Pinheiro16} and the \code{lmer} and \code{glmer} functions in the \pkg{lme4} package \citep{Bates15}; linear and generalized linear mixed models fit with penalized quasilikelihood (PQL) \citep{VenablesRipley02}, and latent class models fit by \code{poLCA} in the \pkg{poLCA} package \citep{Linzer11}. This is hardly an exhaustive list of fitting methods that are based on a linear predictor, and we have been asked from time to time to write functions to use \code{effects} with this other fitting methods.  The mechanism for this is fairly simple.  This vignette assumes you are familiar with \R{}'s S3 methods.

The default \code{Effect.default} may work with some modeling functions, as would objects of the class \code{merMod} that we describe below in Section~\ref{merMod}, but as illustrated in this ignette some modification will often be required.

The \code{effect} package has five functions that create the information needed for drawing effects plots, \code{Effect}, \code{allEffects}, \code{effect} and \code{predictorEffect} and \code{predictorEffects}.  To add new modeling to the package only a new \code{Effect} needs to be written; the package will take care of all the other functions.

This revision of this vignette is appropriate for Version 4.1-5 of \code{effects}, and includes discussion of the \code{insight} package described at \url{https://easystats.github.io/insight/} that can be used to simplify writing \code{Effect} methods for models we have not included with  \code{effects} package, as we illustrate in the examples below.

\section{Using \pkg{effects} with Other Modeling Methods, with Generalized Least Squares in the \pkg{nlme} Package as an Example}\label{gls}
Applying \code{effects} to other than \code{lm} and \code{glm} objects may require writing a method for the \code{Effect} generic function for that type of model object.  For example, the \code{gls} function in the \code{nlme} package \citep{nlme} fits linear models via generalized least squares.  A call to \code{gls} creates an object of class \code{gls}.  The following function \code{Effect.gls} provides a method for \code{gls} objects by finding the information needed to draw effects plots from \code{gls} objects:

<<eval=FALSE>>=
Effect.gls <- function(focal.predictors, mod, ...){
  cl <- mod$call
  cl$weights <- NULL
  args <- list(
    type = "glm",
    call = cl,
    formula = insight::find_formula(mod),
    family = NULL,
    coefficients = coef(mod),
    vcov = insight::get_varcov(mod),
    method=NULL)
  Effect.default(focal.predictors, mod, ..., sources=args)
}
@
The \code{Effect.gls} function has three required arguments, \code{focal.predictors} and \code{mod} that match the first two arguments of \code{Effect.default}, and  \code{...} that matches any other arguments you would like to pass to \code{Effect.default}; see \code{help(Effect)} for a list of these arguments.

The body of the function simply harvests the needed information from the \code{mod} object, and stores them in a list of named elements called \code{sources}.  The \code{sources} list is then passed as a named argument to the default \code{Effect} method.

The named elements in \code{sources} include:
\begin{description}
\item[\texttt{type}] The \code{effects} package has three basic modeling functions:  \code{type = "glm"}, the default, is used for functions with a univariate response and a linear predictor and possibly a link function.  This class includes linear models, generalized linear models, robust regression, generalized least squares fitting, linear and generalized linear mixed effects models, and many others. The \code{type = "polr"} is used for ordinal regression models, as in the \code{polr} function in the \code{MASS} package, and similar methods described below in Section~\ref{polr}.  The The \code{type = "multinom"} for multinomial log-linear models as fit by the \code{multinom} function in \code{nnet}, and to polytomous latent class models created with the \code{poLCA} function in the \pkg{poLCA} package.  The default is \code{type = "glm"}.

\item[\code{call}] The \code{Effect.default} method may use the call to set additional arguments that it needs.  For \code{type="glm"}, for example, these arguments are \code{formula}, \code{data}, \code{contrasts},  \code{subset},
\code{family}, \code{weights}, and \code{offset}, although only the \code{formula} argument is required.  The \code{gls} function includes an optional \code{weights} argument that is used differently from the \code{weights} argument for a generalized linear model and is not needed for computing effects or predictor effects plots.  In the function shown above the call is modified by setting \code{weights=NULL}.  

The default for \code{call} is \code{mod\$call} for S3 objects and \code{mod@call} for S4 objects.

\item[\code{formula}] This argument should return the formula for the fixed-effects part of the model that is being fit.  For many models the correct formula is returned by  \verb+insight::find_formula(mod)$conditional+ using the \code{insight} package.  This is the default for this argument.  If this does not work for a particular application the user must set the argument to be the value of the formula.  

Should the default not work, try using \code{formula(mod)}. If this works, simply set the argument \code{formula = formula(mod)}. This will likely not work if your model has fixed and random effects, or other types of linear predictors. In that case, you will need to write your own \verb+find_formula+ method.  For example, for a modeling function \code{mymod}, 
\begin{alltt}
find\_formula.mymod <- function(mod, ...)\{
  formula <- \mbox{\emph{...code to extract the formula}}
  c(conditional=formula)
\}
\end{alltt}
This function will then be used by \code{effects} as needed.  In this case you should not set the \code{formula} argument.

\item[\code{family}] 
This argument is required for GLM-like models that include a \code{family} that specifies both an error distribution and a link function only if \code{family=family(mod)} is not appropriate.  See the \code{betareg} example in Section~\ref{betareg} below for an example that includes a user-selected link function, but a fixed error distribution.

\item[\code{coefficients}] For linear, generalized linear and gls models the fixed-effect coefficient estimates are returned by \code{coef(mod)}, but this is usually not adequate for more complicated modeling functions.  The default for this argument if it is not set is \code{effCoef(mod)}, which is defined as a generic function as follows:
<<eval=FALSE>>=
effCoef <- function(mod, ...){UseMethod("effCoef", mod)}
effCoef.default <- function(mod, ...){
  est1 <- insight::get_parameters(mod, ...)
# est1 is a data frame, with labels in col 1 and values in col 2
# convert to a vector with named elements
  est <- est1[,2]
  names(est) <- est1[,1]
  est
}
@
This function returns fixed-effects coefficients for a variety of models including models with random effects.  You should consult  \verb+help("get_parameters")+ to see if this will work for a particular modeling paradigm.  If it does not work you can write your own \code{effCoef} method.


\item[\code{zeta}] Ordinal regression models return both a set of regression coefficients and also a set of \emph{threshholds}.  In the \code{polr} function the regression coefficients and the threshholds are stored in separate vectors, but in other ordinal regression programs, such as \code{clm} in the \code{ordinal} package they are stored as a single vector.  See Section~\ref{polr} for an example of the use of this argument for specifying the values of the threshholds. 

\item[\code{vcov}] The function \verb+insight::get_varcov(mod)+ is the default for this argument and it will generally return the estimated covariance matrix of the fixed-effects, but in some cases the user may need to write their own function for this purpose; see \verb+help("get_varcov")+ for more information. 

\item[method] This argument is used only for methods that use effects graphics based on the \code{polr} function, where the argument \code{method} is the name of a link function; see \code{help("polr")} for a list of the accepted links, and see Section~\ref{clm} below for an example.
\end{description}
The only non-default argument in \code{sources} in \code{Effect.gls} is the modification of the \code{call} to omit weights in the call to \code{gls}.  Had this change not been needed, there would be no need to have written the \code{Effect.gls} method, as the default method would have worked. The function with all the defaults omitted is
<<eval=FALSE>>=
Effect.gls <- function(focal.predictors, mod, ...){
  cl <- mod$call
  cl$weights <- NULL
  args <- list(call=cl)
  Effect.default(focal.predictors, mod, ..., sources=args)
}
@

<<fig.height=4,fig.width=8>>=
library(effects)
require(nlme)
g1 <- gls(Employed ~ GNP + Population,
         correlation=corAR1(form= ~ Year), data=longley)
plot(predictorEffects(g1))
@

\section{Mixed Effects with \code{lme} (\pkg{nlme} package)}\label{merMod}
With the inclusion of functions in the \code{insight} package, models created with the
\code{lme} function in the \pkg{nlme} package \citep{nlme} for linear mixed models can be fit by the default \code{Effect} method because the functions in the \code{insight} package get the correct quantities.
<<>>=
data(Orthodont, package="nlme")
m1 <- nlme::lme(distance ~ age + Sex, data=Orthodont, 
                random= ~ 1 | Subject)
as.data.frame(Effect("age", m1))
@

\section{Mixed Effects with the \code{lmer} (\code{lme4} package)}\label{sec:lmer}
The \code{lme4} package \citep{Bates15} fits linear and generalized linear mixed effects models with the \code{lmer} and \code{glmer} functions, respectively.  The same \code{Effect} function can be used for \code{lmer} and \code{glmer} models. 

The \code{effects} method for these models allows two choices for computing an estimated covariance matrix, using the Kenward-Roger estimate if the argument \code{KR = TRUE}, and the usual estimate from the fit when \code{KR = FALSE}.  The default is \code{FALSE} because the KR computation is very slow.  If \code{KR = TRUE}, the function also checks if the \pkg{pbkrtest} package is present.  The family needs to be explicitly set, but all the defaults for other arguments are appropriate for this model.  

<<>>=
print(Effect.merMod)
@


<<fig.height=4,fig.width=8>>=
fm2 <- lme4::lmer(distance ~ age + Sex + (1 |Subject), data
                  = Orthodont)
plot(allEffects(fm2))
@

<<>>=
data(cbpp, package="lme4")
gm1 <- lme4::glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial)
as.data.frame(predictorEffect("period", gm1))
@

\section{Linear and Generalized Linear Mixed Models Fit With \code{glmmPQL}}
\cite{VenablesRipley02} provide a penalized quasi-likelihood function for fitting linear and generalized linear mixed models in their \code{MASS} package. The \code{Effect} package only provides the family argument.


<<>>=
print(Effect.glmmPQL)
@

\section{Robust Linear Mixed Models (\pkg{robustlmm} package)}
The \code{rlmer} function in the \code{robustlmm} package \citep{koller16} fits linear mixed models with a robust estimation method.  As \code{rlmer} closely parallels the \code{lmer} function, an object created by \code{rlmer} is easily used with \code{effects}:
<<>>=
print(Effect.rlmerMod)
@

<<eval=FALSE,fig.height=4, fig.width=8>>=
require(lme4)
fm3 <- robustlmm::rlmer(distance ~ age * Sex + (1 |Subject), 
                        data = Orthodont)
plot(predictorEffects(fm3))
@

\section{Beta Regression}\label{betareg}
The \code{betareg} function in the \code{betareg} package \citep{betareg} fits regressions with a link function but with Beta distributed errors.
<<>>=
print(Effect.betareg)
@
Beta regression has a response $y \in [0,1]$, with the connection between the mean $\mu$ of the Beta and a set for predictors $\x$ through a link function $\x'\bbeta = g(\mu)$.  The variance function for the beta is $\mathrm{var}(y) = \mu(1-\mu)/(1+\phi)$, for a precision parameter $\phi$ estimated by \code{betareg}.

The method \code{Effect.betareg} is more complicated than the methods previously described:
\begin{description}
\item[coef] The default for this argument is \verb+insight::find_parameters(mod)+ returns the coefficients for the linear predictor and for the precision parameter, as shown on its help page.  The correct call is\\ \verb+insight::find_parameters(mod, component="conditional")+.
\item[vcov] Similarly, the estimated covariance matrix of the linear predictor components is \verb+insight::get_varcov(mod, component="conditional")+.
\item[family] The call to \code{betareg} does not have a family argument, although it does have a link stored in \code{mod\$link\$mean}.  For use with \code{Effect.default}, the method above creates a family from the binomial family generator.  It then adjusts this family by changing from binomial variance to the variance for the beta distribution. Since the \code{glm} function expects a variance that is a function of only one parameter, we fix the value of the precision $\phi$ at its estimator from the \code{betareg} fit.  We need to replace the \code{initialize} method in the family to one appropriate for $y \in [0,1]$.
\end{description}

<<echo=FALSE,results='hide', include=FALSE>>=
require(lme4)
@
<<fig.height=4,fig.width=8,cache=FALSE>>=
require(betareg)
require(lme4)
data("GasolineYield", package = "betareg")
gy_logit <- betareg(yield ~ batch + temp, data = GasolineYield)
summary(gy_logit)
plot(predictorEffects(gy_logit))
@

\section{Ordinal Models (\pkg{ordinal} package)}\label{polr}
Proportional odds logit and probit regression models fit with the \code{polr} function in the \code{MASS} package \citep{VenablesRipley02} are supported in the \code{effects} package.  The \code{ordinal} package, \citep{Christensen15} contains three functions that are very similar to \code{polr}.  The \code{clm} and \code{clm2} functions allow more link functions and a number of other generalizations.  The \code{clmm} function allows including random effects.

The methods for ordinal models are considerably more complex than are the preceding examples.  In particular, the function \code{clm} is not supported by the \code{insight} package, although \code{clm2} and \code{clmm} are supported.

\subsection{\code{clm}}\label{clm}
<<>>=
print(Effect.clm)
@

This method first checks that the \code{MASS} package is available.  The \code{clm} function orders the parameters in the order (threshold parameters, linear predictor parameters), so the next few lines identify the elements of  \code{vcov} that are needed by \code{Effects}.  Since the \code{polr} function does not allow thresholds other than \code{flexible}, we don't allow them either. The \code{zeta} argument supplies the estimated threshholds, which are called \code{zeta} in \code{polr}, and \code{Alpha} in \code{clm}. The \code{polr} argument \code{method} is equivalent to the \code{clm} argument \code{link}, except that the \code{clm} link \code{"logit"} is equivalent to the \code{polr} method \code{"logistic"}.  

<<echo=FALSE,results='hide', include=FALSE>>=
require(ordinal)
require(MASS)
@
<<fig.height=6,fig.width=6>>=
require(ordinal)
require(MASS)
mod.wvs1 <- clm(poverty ~ gender + religion + degree + country*poly(age,3),
    data=WVS)
plot(Effect(c("country", "age"), mod.wvs1), 
     lines=list(multiline=TRUE), layout=c(2, 2))
@

\subsection{\code{clm2}}
Although the fitted madels are similar, syntax for \code{clm2} is not the same as \code{clm}, so a separate method is required.

<<>>=
print(Effect.clm2)
@

<<fig.height=6,fig.width=8>>=
v2 <- clm2(poverty ~ gender + religion + degree + country*poly(age,3),data=WVS)
plot(emod2 <- Effect(c("country", "age"), v2), 
     lines=list(multiline=TRUE), layout=c(2,2))
@

\subsection{\code{clmm}}
This function allows for random effects in an ordinal model.
<<>>=
print(Effect.clmm)
@
The first few lines of the method check for the presence of the \code{MASS} package that is needed to use \code{polr}, makes sure the link used is supported by \code{polr}, and requires that the argument \code{threshold} has its default value.  The \code{polr} and \code{clmm} functions store the fixed effects estimates of regression and threshold coefficents in different orders, so the next few lines rearrange the variance matrix to match the order that \code{polr} uses.

<<fig.height=4,fig.width=4,cache=FALSE>>=
require(ordinal)
require(MASS)
mm1 <- clmm(SURENESS ~ PROD + (1|RESP) + (1|RESP:PROD), 
        data = soup, link = "logit", threshold = "flexible")
plot(Effect("PROD", mm1),lines=list(multiline=TRUE))
@

\subsection{Others}
The \code{poLCA} function in the \code{poLCA} package \citep{Linzer11} fits polytomous variable latent class models, which uses the multinomial effects plots.

The \code{svyglm} function in the \code{survey} package \citep{Lumley04, Lumley16} fits generalized linear models using survey weights.

The \code{lm} function can also be used to create a multivariate linear model.  The \code{Effect.mlm} function, with slightly different syntax, will drow effects plots for these models, with separate plots of each response.

<<fig.height=6,fig.width=6>>=
data(Baumann, package="carData")
b1 <- lm(cbind(post.test.1, post.test.2, post.test.3) ~ group + 
    pretest.1 + pretest.2, data = Baumann)
plot(Effect("group", b1))
@




\bibliography{adding-Effect-methods}
\end{document}


