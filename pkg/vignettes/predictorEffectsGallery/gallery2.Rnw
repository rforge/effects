% !Rnw root = gallery.Rnw

\section{Optional Arguments for the \fn{predictorEffect} and \fn{Effect} Functions}\label{sec:peopts}

This section comprises a catalog of the arguments available to modify the behavior of the \fn{predictorEffect} and \fn{Effect} functions.  The information provided by \code{help("Effect")} is somewhat more comprehensive, if terser, explaining for example exceptions applying to \class{svyglm} objects or for plotting residuals.

\subsection{\ar{xlevels}: Options for the Focal Predictor and Predictors in the Conditioning Group}

Numeric predictors in the conditioning group need to be discretized to draw a predictor effect plot.  For example the predictor effect plot for \vn{type} in model \code{lm1} consists of a separate line, or a separate panel, for each discrete value of \vn{income}:
<<fig21a,include=TRUE,fig.width=5,fig.height=4.5,fig.show='hide'>>=
e3.lm1 <- predictorEffect("type", lm1)
plot(e3.lm1, lines=list(multiline=TRUE))
@
\centerline{\includegraphics[width=4in]{figure/fig21a-1.pdf}}
<<fig21b,include=TRUE,fig.width=6,fig.height=5,fig.show='hide'>>=
plot(e3.lm1, lines=list(multiline=FALSE)) # the default
@
\centerline{\includegraphics[width=4in]{figure/fig21b-1.pdf}}

\noindent
The numeric conditioning predictor \vn{income} is evaluated by default at five
equally spaced values, and then rounded to ``nice" numbers.  

In this example using three values of 5000, 15000, 25000 might produce a graph that's easier to decode:
<<fig22a,include=TRUE,fig.width=5,fig.height=4.5,fig.show='hide'>>=
e3.lm1 <- predictorEffect("type", lm1,
                          xlevels=list(income=c(5000, 15000, 25000)))
plot(e3.lm1, lines=list(multiline=TRUE),
     confint=list(style="bars"))
@
\centerline{\includegraphics[width=4in]{figure/fig22a-1.pdf}}
<<fig22b,include=TRUE,fig.width=5.5,fig.height=5,fig.show='hide'>>=
plot(e3.lm1,
     lines=list(multiline=FALSE), # the default
     lattice=list(layout=c(3, 1)))
@
\centerline{\includegraphics[width=4in]{figure/fig22b-1.pdf}}

\noindent
The argument \ar{xlevels} is a list of sub-arguments that control how numeric predictors are discretized when used in the conditioning group.  For example, \code{xlevels=list(x1=c(2, 4, 7), x2=6)} would use the values 2, 4, and 7 for the levels of the predictor  \code{x1}, use 6
equally spaced values for the predictor \code{x2}, and use the default of 5 values for any other numeric predictors.  Numeric predictors in the \emph{fixed} group are not affected by the \ar{xlevels} argument. We use the \ar{layout} sub-argument of the \ar{lattice} argument to arrange the panels of the second graph in 3 columns and 1 row (see Section~\ref{sec:layout}).

The number of points at which the focal predictor is evaluated is also controlled by the \ar{xlevels} argument. Increasing the number of points may make plotted lines smoother or more accurate.  See \code{help("plot.eff")} for information on the \ar{quantiles} argument, which provides an alternative method of setting \ar{xlevels} when partial residuals are displayed (as discussed in Section~\ref{sec:res}).

\subsection{\ar{fixed}: Options for Predictors in the Fixed Group}

Predictors in the fixed group are replaced by ``typical" values of the predictors.  Fitted values are then computed using these typical values for the fixed group, varying the values of predictors in the conditioning group and of the focal predictor. The user can control how the fixed values are determined  by specifying the \ar{fixed.predictors} argument.  This argument takes a list of sub-arguments that allow for controlling each predictor in the fixed group individually, with different rules for factors and numeric predictors.

\subsubsection{Factor Predictors}\label{sec:facpred}

For a fixed factor, imagine computing the fitted values evaluating the factor at each of its levels.  The fitted value that is used is the weighed average of these within-level fitted values, with weights proportional to the number of observations at each level of the factor. This is the default approach, and is an appropriate notion of ``typical" if the data at hand are viewed as a random sample from a population, and so the sample fraction at each level estimates the population fraction. Proportional weighting is implemented simply by averaging the columns of the model matrix pertaining to a factor.

A second approach is to average the level-specific fitted values with equal weights at each level. This may be  appropriate, for example, in designed experiments in which the levels of a factor are assigned by an investigator.  The latter method is invoked by setting \code{fixed.predictors= list(given.values="equal")}.

You can construct other weighting schemes for averaging over the levels of a factor, as described on the help page for the \fn{Effect} function.

\subsubsection{Numeric Predictors}

For numeric predictors in the fixed group, the default method of selecting a typical value is to apply the \fn{mean} function to the sample values of each predictor.  The specification \code{fixed.predictors= list(typical=median)} would instead use the \fn{median} function; in general, \ar{typical} can be any function that takes a numeric vector as its argument and returns a single number.

Other sub-arguments to \ar{fixed.predictors} apply to the use of offsets, and to the \pkg{survey} package; see the help page for the \fn{Effect} function.

\subsection{\ar{se}: Standard Errors and Confidence Intervals}\label{sec:se}

Standard errors and confidence intervals for fitted values are computed by default.  The default corresponds to setting the argument \code{se=list(compute=TRUE, type="pointwise", level=.95)}.  Setting \code{se=FALSE} omits standard errors, \ar{type="scheffe"} uses wider Scheff\'{e} intervals that adjust for simultaneous inference, and \code{level=.8}, for example, produces 80\% intervals.

Standard errors are based by default on the ``usual" sample covariance matrix of the estimated regression coefficients. You can replace the default coefficient covariance matrix with some other estimate, such as one obtained from the bootstrap or a sandwich coefficient covariance matrix estimator, by setting the  \ar{vcov.}~argument either to a function that returns a coefficient covariance matrix, such as \fn{hccm} in the \pkg{car} package for linear models, or to a matrix of the correct size; for example:
<<fig23,include=TRUE,fig.width=5,fig.height=4,fig.show='hide'>>=
e4.lm1 <- predictorEffect("education", lm1,
                          se=list(type="scheffe", level=.99),
                          vcov.=hccm)
plot(e4.lm1)
@

\centerline{\includegraphics[width=4in]{figure/fig23-1.pdf}}

\noindent
This plot displays 99\% Scheff\'{e} intervals based on a robust coefficient covariance matrix computed by the sandwich method; see \code{help("hccm")}.

\subsection{\ar{residuals}: Computing Residuals}

The argument \ar{residuals=TRUE} computes and saves residuals, providing the basis for adding partial residuals to subsequent effect plots, a topic that we discuss in Section~\ref{sec:res}.

